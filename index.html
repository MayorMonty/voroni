<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="main.css" />
    <title>Voronoi Diagrams</title>
  </head>
  <body>
    <main>
      <header class="margin-bottom">
        <h1 class="title">
          Generating Voronoi Diagrams: How Do We Do It For Real?
        </h1>
        <h3 class="subhead">
          <span class="orange">23 July 2021</span>
        </h3>
      </header>

      <p>[Introduction of Voronoi Diagrams]</p>

      <h2 class="title">Voronoi Diagram</h2>
      <section class="dashed-top" id="voronoi-intro">
        <a href="#voronoi-intro" class="permalink">#</a>
        <p>
          So what is a Voronoi Diagram exactly? Imagine we a number of random
          points in space (these points are usually called the <em>sites</em> of
          the diagram). The goal is to divide space into regions—one for each
          site—such that
          <em
            >each point in that region is closer to its specific site than any
            other site.</em
          >
        </p>

        <p>
          You can see an example of what exactly this means below. Move your
          cursor (or finger) over the region below to see what the closest site
          is at that point. See if you can find the areas where the closest site
          changes
        </p>
      </section>

      <canvas id="demo-1" height="900" width="1600"></canvas>
      <section class="controls">
        <div class="control">
          <label>
            <span>Number of Points</span>
            <input
              type="number"
              min="2"
              max="12"
              step="1"
              value="4"
              id="demo-1-points"
            />
          </label>
        </div>
        <button id="demo-1-regenerate" class="outlined">regenerate</button>
      </section>

      <p>
        If you trace the graph long enough, you may be able to work out where
        some of the edges of the Voronoi Diagram are. But how could we create a
        more systematic approach to this?
      </p>

      <h2 class="title">Approach #1: Naive Approach</h2>
      <section class="dashed-top" id="naive">
        <a href="naive" class="permalink">#</a>
        <p>Let's start with the simplest way to do this: what if, for every pixel, we just measure
        and record the shortest distance.</p>

        <blockquote class="mono">
          <p class="line i0">let shortest = map(point => site)</p>
          <p class="line i0">for each point in plane {</p>
            <p class="line i1">let closest_site;</p>
            <p class="line i1">let closest_distance;</p>
            <p class="line i1">for each site in sites {</p>
              <p class="line i2">let distance = distance(point, site);</p>
              <p class="line i2">if distance < closest_distance {</p>
                <p class="line i3">closest_site = site;</p>
                <p class="line i3">closest_distance = distance;</p>
              <p class="line i2">}</p>
            <p class="line i1">}</p>
            <p class="line i1">shortest[point] = closest_site</p>
          <p class="line i0">}</p>
        </blockquote>

        <p>So, let's try it! The demo below will iterate through every pixel in the plane
        (160x90), and determine the closest voronoi site. </p>

        <canvas id="demo-2" height="180" width="320"></canvas>
        <section class="controls">
          <div class="control">
            <label>
              <span>Number of Points</span>
              <input
                type="number"
                min="2"
                max="9"
                step="1"
                value="4"
                id="demo-2-points"
              />
            </label>
          </div>
          <button id="demo-2-go" class="outlined">Go!</button>
        </section>

        <blockquote class="info">
          The source code for every demo in this article can be found on my <a href="https://github.com/MayorMonty/voronoi/">GitHub</a>
        </blockquote>

        <p>This method actually does have a few advantages:</p>
        <ul>
          <li>After the process is complete, we have a lookup table of pixel to site, which means
          that we don't need to do any further computation</li>
          <li>Relatively simple to understand and implement</li>
        </ul>

        <p>However, there are a number of big disadvantages, which you can see in the demo below</p>

        

      </section>

      <h2 class="title">Approach #2: Fortune's Algorithm</h2>
      <section class="dashed-top" id="fortunes-algorithm">
        <a href="#fortunes-algorithm" class="permalink">#</a>
        <p></p>
      </section>

      <h2 class="title">Approach #3: Dulaney Triangulation</h2>
      <section class="dashed-top" id="dulaney-triangulation">
        <a href="#dulaney-triangulation" class="permalink">#</a>
        <p></p>
      </section>

      <h2 class="title">What's The Best?</h2>
      <section class="dashed-top" id="whats-the-best">
        <a href="#whats-the-best" class="permalink">#</a>
        <p></p>
      </section>

      <!-- <canvas id="canvas" height="900" width="1600"></canvas>
      <section class="controls">
        <div class="control">
          <label>
            <span>Number of Points</span>
            <input type="number" min="2" max="12" step="1" value="4" id="points" />
          </label>
        </div>
        <button id="regenerate" class="outlined">regenerate</button>
      </section> -->
    </main>
  <script type="text/javascript" src="main.js"></script></body>
</html>
